
function parseUrlParam(url) {
    // 解析查询字符串部分
    const queryString = url.split('?')[1];
    const pairs = queryString.split('&');
    const urlObject = {};
  
    // 遍历键值对，解析成对象属性
    pairs.forEach(pair => {
      const [key, value] = pair.split('=');
      let decodedValue;
  
      if (value === undefined) {
        // 如果没有指定值，则将属性值设置为 true
        decodedValue = true;
      } else if (!isNaN(value)) {
        // 如果值可以被转成数字，则将属性值设置为数字类型
        decodedValue = Number(value);
      } else {
        // 否则将属性值解码成中文
        decodedValue = decodeURIComponent(value);
      }
  
      // 如果该属性已经存在，则将值添加到数组中
      if (urlObject.hasOwnProperty(key)) {
        if (Array.isArray(urlObject[key])) {
          urlObject[key].push(decodedValue);
        } else {
          urlObject[key] = [urlObject[key], decodedValue];
        }
      } else {
        // 否则直接设置属性值
        urlObject[key] = decodedValue;
      }
    });
  
    return urlObject;
  }

function solution(s) {
    const count = {};
  
    // 统计每个字符出现的次数
    for (let i = 0; i < s.length; i++) {
      if (count[s[i]] === undefined) {
        count[s[i]] = 1;
      } else {
        count[s[i]]++;
      }
    }
  
    // 找到第一个出现次数为 1 的字符
    for (let i = 0; i < s.length; i++) {
      if (count[s[i]] === 1) {
        return i;
      }
    }
  
    return -1;
  }

2
3
7
8
4
5
1
6
解析：

首先，setTimeout 会在 100ms 后执行，因此不会影响 Promise 的执行过程。因此，它在 Promise 之后执行，输出 1。
接着，Promise 会立即执行，输出 2，然后执行 resolve()，输出 3。
接下来，会输出 7 和 8，因为它们是直接在代码顶层执行的语句。
然后，Promise.then() 方法会在 Promise 执行结束后执行，输出 4。
在 Promise.then() 中，又创建了一个新的 Promise，因此它会立即执行，输出 5。然后，由于这个新的 Promise 中包含了一个 setTimeout，因此会在 10ms 后执行，输出 6。
因此，整个程序的输出结果就是以上所示的顺序


代码的输出结果是：

4
2
1

这是因为在该代码中，定义了一个名为Foo的函数，然后在函数体内部又定义了一个静态方法a。接着，通过给原型对象Foo.prototype添加一个名为a的方法来给实例对象obj添加方法a。最后，调用了三次方法a。

首先，执行Foo.a()时，会输出4。因为在函数体内部定义的静态方法a，所以在调用时直接输出4。

接着，通过new Foo()创建了一个实例对象obj，并且调用obj.a()，此时会输出2。因为在实例对象中存在一个名为a的方法，所以输出2。

最后，调用Foo.a()时，会输出1。因为在函数体内部定义的静态方法a已经被覆盖了，所以此时输出的是1。


你是否曾经面对过非常复杂的问题或任务？你又是如何成功地解决它的？

是的，我曾经遇到过一些非常复杂的问题或任务。其中最具挑战性的任务之一是在一个大型电商网站上实现复杂的交互功能。这项任务需要我从头开始构建一个大型的交互组件，并且需要解决许多技术难题。

在处理这个任务的过程中，我采用了以下步骤：

确定需求：首先，我花了很多时间与产品和设计团队沟通，以确保我完全理解他们的需求和期望。我详细记录下来所有的需求和细节，并开始着手制定一个具体的计划。

设计交互组件：接下来，我开始设计和构建交互组件。我在这个过程中使用了一些先进的前端技术，例如React和Redux，以确保我能够快速且可靠地构建一个高性能的组件。我同时也考虑到了组件的可维护性和扩展性，以便在未来维护和更新组件时更加容易。

解决技术难题：在实现这个任务的过程中，我遇到了一些技术难题，例如跨浏览器兼容性、性能优化和安全问题。为了解决这些难题，我进行了广泛的研究，同时寻求了一些前辈和同事的帮助和建议。最终，我成功地克服了所有的技术难题，实现了一个非常强大和高效的交互组件。

测试和调试：最后，我进行了大量的测试和调试，以确保组件的功能和性能符合预期。我测试了不同的使用场景和浏览器，并使用了一些性能测试工具和调试工具来检查和优化代码。在最终的测试中，我发现了一些小的问题并及时修复了它们。

总的来说，这项任务对我的技术能力和团队合作能力提出了很高的要求，但通过我和团队的努力，最终成功地完成了任务。我从中获得了很多经验和教训，并且不断完善自己的技术和知识，以更好地应对未来的挑战。






你需要跟上司沟通工作，但他的每天的日程很满，经常会有更紧急的事情排在你前面，你如何去跟他协调沟通的时间？

面对这种情况，我通常会采取以下措施：

与上司共享日程：了解上司的日程安排，可以让我更好地规划我的时间，并找到更适合他的时间来进行沟通。如果上司愿意，我会与他共享我的日程表，这样他也可以知道我什么时候比较空闲，什么时候不方便。

找到紧急程度：当我需要与上司沟通时，我会尽量先弄清楚任务的紧急程度。如果这个任务很紧急，我会尝试找到一个比较紧急但不会影响上司日程的时间。如果这个任务不是很紧急，我会选择一个比较合适的时间，以便上司可以从他的日程中挤出一些时间与我进行沟通。

提前预约：如果我需要与上司进行的沟通较为重要，我会提前与他预约时间，这样可以让他尽量从他的日程中挤出时间来。同时，我会告诉他我需要沟通的事项，这样他可以在沟通之前有更充分的准备。

沟通方式：如果上司的日程比较忙，我会尝试用电子邮件或即时通讯工具与他进行沟通。这种方式可以让他在忙碌的时间里也能回复我，如果有必要，我们可以通过电话或面谈进一步沟通。

总之，我会尝试多种方式来协调时间，以便与上司进行有效的沟通，同时也会尊重他的日程安排。这样可以保持良好的合作关系，也可以确保工作的高效执行。

